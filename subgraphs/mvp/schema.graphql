type Asset @entity {
  "Address (hash)"
  id: ID!

  isWhitelisted: Boolean!

  # used for other stats like marketcap
  totalSupply: BigInt!
  # mirrored from the smart contract
  decimals: BigInt!
  symbol: String!
  name: String!

  indexCount: BigInt!
  _indexes: [ID!]!
  indexes: [IndexAsset!]! @derivedFrom(field: "asset")

  basePriceSushi: BigDecimal!
  basePriceUni: BigDecimal!
  basePrice: BigDecimal!
  marketCap: BigInt!

  _vTokens: [ID!]!
  vTokens: [vToken!]! @derivedFrom(field: "asset")

  vaultReserve: BigDecimal!
  vaultBaseReserve: BigDecimal!

  pairsAsAsset0: [Pair!]! @derivedFrom(field: "asset0")
  pairsAsAsset1: [Pair!]! @derivedFrom(field: "asset1")

  dailyStats: [DailyAssetStat!]! @derivedFrom(field: "asset")

  oracle: UniV3PriceOracle
}

type Swap @entity {
  id: ID!

  pairs: [Pair!]! @derivedFrom(field: "swap")
}

type ChainLink @entity {
  id: ID!
  aggregator: ChainLinkAgg!
}

type ChainLinkAgg @entity {
  id: ID!
  chainLink: ChainLink!
  asset: Asset!
  decimals: BigInt!
  description: String!
  answer: BigInt!
  updatedAt: BigInt!
  nextAgg: ChainLinkAgg
}

type Pair @entity {
  id: ID!

  swap: Swap!

  asset0: Asset!
  asset1: Asset!

  totalSupply: BigInt!

  asset0Reserve: BigDecimal!
  asset1Reserve: BigDecimal!
}

type SushiPair @entity {
  id: ID!

  swap: Swap!

  asset0: Asset!
  asset1: Asset!

  totalSupply: BigInt!

  asset0Reserve: BigDecimal!
  asset1Reserve: BigDecimal!
}

type DEX @entity {
  id: ID!
  router: String!
  type: String!
}

type IndexFactory @entity {
  "Address (hash) of the factory"
  id: ID!
  type: String!

  vTokenFactory: String!

  indices: [Index!]! @derivedFrom(field: "indexFactory")
}

type Index @entity {
  "Address (hash)"
  id: ID!
  type: String!

  # used for other stats like marketcap
  totalSupply: BigInt!
  # metadata
  decimals: BigInt!
  symbol: String!
  name: String!

  users: [UserIndex!]! @derivedFrom(field: "index")
  assets: [IndexAsset!] @derivedFrom(field: "index")
  _assets: [ID!]!

  _inactiveAssets: [ID!]!
  inactiveAssets: [IndexAsset!] @derivedFrom(field: "inactiveIndex")

  transaction: Transaction!
  indexFactory: IndexFactory!

  marketCap: BigDecimal!
  uniqueHolders: BigInt!
  "price of the index in USD"
  basePrice: BigDecimal!
  "price of the index in ETH"
  basePriceETH: BigDecimal!
  "deprecated"
  baseVolume: BigDecimal!

  feeBurn: BigInt!
  feeMint: BigInt!

  "BP = 10000 ; ((((aumFeeInBP / BP) / (1 - aumFeeInBP / BP)) / 1e27) ** 365) - 1"
  feeAUMPercent: BigDecimal!

  "When index was created"
  created: BigInt!
  "Index Creation Category"
  sector: BigInt!

  hourlyStats: [HourlyIndexStat!]! @derivedFrom(field: "index")
  dailyStats: [DailyIndexStat!]! @derivedFrom(field: "index")
  weeklyStats: [WeeklyIndexStat!]! @derivedFrom(field: "index")
  monthlyStats: [MonthlyIndexStat!]! @derivedFrom(field: "index")
  yearlyStats: [YearlyIndexStat!]! @derivedFrom(field: "index")
}

type Order @entity {
  "Address (hash)"
  id: ID!
  index: Index!
  order_id: BigInt!
  orderDetails: [OrderDetailsInfo!]! @derivedFrom(field: "order")
}

type OrderDetailsInfo @entity {
  id: ID! # Set to `${order.id}-${asset.id}`
  order: Order!
  asset: Asset!
  shares: BigInt!
  side: String!
}

type LastOrderIndex @entity {
  id: ID!
  index: Index!
  order: Order!
}

type vToken @entity {
  "Address (hash)"
  id: ID!
  asset: Asset!
  tokenType: String!
  factory: String!
  platformTotalSupply: BigInt!
  platformTotalSupplyDec: BigDecimal!
  capitalization: BigDecimal!
  "depositedQuantity"
  deposited: BigInt!
  "reserveQuantity - quantity of the asset stored in vToken address"
  assetReserve: BigInt!
  "totalAmount - is the sum of assetReserve and deposited without taking interests into account"
  totalAmount: BigInt!
}

type IndexAsset @entity {
  id: ID! # Set to `${index.id}-${asset.id}`
  index: Index
  inactiveIndex: Index
  asset: Asset!
  weight: BigInt!
  shares: BigInt!
}

type User @entity {
  id: ID!

  indexes: [UserIndex!]! @derivedFrom(field: "user")
}

type UserIndex @entity {
  id: ID!

  user: User!
  index: Index!

  balance: BigDecimal!
  capitalization: BigDecimal!
}

type UserCapitalization @entity {
  id: ID!

  index: Index!
  capitalization: BigDecimal!
  timestamp: BigInt!
  logIndex: BigInt!
}

type DailyCapitalization @entity {
  id: ID!
  "index referred to daily capitalisation metrics"
  index: Index!
  "capitalisation for the specific day"
  capitalization: BigDecimal!
  "price of the index in the day"
  basePrice: BigDecimal!
  "total supply of the index in specific"
  totalSupply: BigInt!
  "raw timestamp of the specific day"
  timestamp: BigInt!
  "log index value taken from event which triggered storing the metric"
  logIndex: BigInt!
}

type UserIndexHistory @entity {
  id: ID!

  "user account of the specific index holdings"
  user: User!
  index: Index!

  "shares of the index in user account"
  balance: BigDecimal!
  "USD equivalent of the user index holdings"
  capitalization: BigDecimal!
  "index total supply on the moment of the user balance calculation"
  totalSupply: BigInt!

  "holds orders of transfers in transaction"
  logIndex: BigInt!
  "timestamp matching the starting of day GMT"
  timestamp: BigInt!
}

type DailyUserIndexHistory @entity {
  id: ID!

  user: User!
  index: Index!

  total: BigDecimal!
  totalCap: BigDecimal!
  number: BigDecimal!
  avgBalance: BigDecimal!
  avgCapitalization: BigDecimal!

  "index total supply on the moment of the user balance calculation"
  totalSupply: BigInt!
  "timestamp matching the starting of day GMT"
  timestamp: BigInt!
  "holds orders of transfers in transaction"
  logIndex: BigInt!
}

type Transaction @entity {
  id: ID! # txn hash
  blockNumber: BigInt!
  timestamp: BigInt!

  value: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!

  transfers: [Transfer!]!
}

enum TransferType {
  Send
  Mint
  Burn
}

type Transfer @entity {
  id: ID! # Set to `${tx.id}-${transfer.id}`
  index: Index!

  transaction: Transaction!

  from: Bytes
  to: Bytes
  value: BigInt!

  type: TransferType!
}

type Stat @entity {
  # index factory address
  id: ID!

  indexCount: BigInt!
  totalValueLocked: BigDecimal!
}

type DailyStat @entity {
  id: ID!
  date: Int!

  indexCount: BigInt!
  totalValueLocked: BigDecimal!
}

type DailyAssetStat @entity {
  id: ID!
  date: Int!
  asset: Asset!

  vaultReserve: BigDecimal!
  vaultBaseReserve: BigDecimal!
  basePrice: BigDecimal!
}

type HourlyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  basePrice: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
}

type DailyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  marketCap: BigDecimal!
  uniqueHolders: BigInt!
  "price of the index in USD"
  basePrice: BigDecimal!
  "price of the index in ETH"
  basePriceETH: BigDecimal!
  baseVolume: BigDecimal!
}

type WeeklyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  "price of the index in USD"
  basePrice: BigDecimal!
  "price of the index in ETH"
  basePriceETH: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
}

type MonthlyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  "price of the index in USD"
  basePrice: BigDecimal!
  "price of the index in ETH"
  basePriceETH: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
}

type YearlyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  "price of the index in USD"
  basePrice: BigDecimal!
  "price of the index in ETH"
  basePriceETH: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
}

# ----------------------------------------------------------------
#                               FRP
# ----------------------------------------------------------------

type FrpVault @entity {
  "Address (hash)"
  id: ID!
  totalSupply: BigInt!
  totalAssets: BigInt!
  decimals: BigInt!
  symbol: String!
  name: String!
  price: BigDecimal!

  apr: BigDecimal!

  mint: [FCash!]!
  redeem: [FCash!]!

  uniqueHolders: BigInt!
  marketCap: BigInt!
}

type FCash @entity {
  id: ID!
  position: String!
  assetAmount: BigInt!
  amount: BigInt!
  maturity: BigInt!
  vault: FrpVault!
  timestamp: BigInt!
  isRedeem: Boolean!
}

type FrpUser @entity {
  id: ID!

  vaults: [UserVault!]! @derivedFrom(field: "user")
}

type UserVault @entity {
  id: ID!

  user: FrpUser!
  frp: FrpVault!

  balance: BigInt!
  capitalization: BigDecimal!
}

enum FrpTransferType {
  Send
  Mint
  Burn
}

type FrpTransfer @entity {
  id: ID!
  frp: FrpVault!
  transaction: FrpTransaction!
  type: FrpTransferType!

  from: FrpUser
  to: FrpUser
  value: BigInt!

  timestamp: BigInt!
}

type FrpTransaction @entity {
  id: ID! # txn hash

  blockNumber: BigInt!
  timestamp: BigInt!

  value: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
}

type FrpDailyStat @entity {
  id: ID!

  date: BigInt!
  vault: FrpVault!

  marketCap: BigInt!
  uniqueHolders: BigInt!
  "price of the vault in USD"
  price: BigDecimal!
}

type FrpDailyCapitalization @entity {
  id: ID!
  "index referred to daily capitalisation metrics"
  index: Index!
  "capitalisation for the specific day"
  capitalization: BigDecimal!
  "price of the vault in the day"
  price: BigDecimal!
  "total supply of frp vault"
  totalSupply: BigInt!
  "raw timestamp of the specific day"
  timestamp: BigInt!
  "log index value taken from event which triggered storing the metric"
  logIndex: BigInt!
}

type UserFrpHistory @entity {
  id: ID!

  "user account of the specific vault holdings"
  user: FrpUser!
  vault: FrpVault!

  "shares of the vault in user account"
  balance: BigInt!
  "USD equivalent of the user vault holdings"
  capitalization: BigDecimal!
  "vault total supply on the moment of the user balance calculation"
  totalSupply: BigInt!

  "holds orders of transfers in transaction"
  logIndex: BigInt!
  "timestamp matching the starting of day GMT"
  timestamp: BigInt!
}

type DailyUserFrpHistory @entity {
  id: ID!

  user: FrpUser!
  vault: FrpVault!

  total: BigDecimal!
  totalCap: BigDecimal!

  "vault total supply on the moment of the user balance calculation"
  totalSupply: BigInt!
  "timestamp matching the starting of day GMT"
  timestamp: BigInt!
  "holds orders of transfers in transaction"
  logIndex: BigInt!
}

# ----------------------------------------------------------------
#                               UniswapV3
# ----------------------------------------------------------------


# stores UniswapV3PriceOracle addresses
type UniV3PriceOracle @entity {
  id: ID!

  priceOracle: String!

  asset0: Asset!
  asset1: Asset!
}

type UniV3PathPriceOracle @entity {
  id: ID!

  pathPriceOracle: String!

  asset0: Asset!
  asset1: Asset!
}

# stores for USD calculations
type UniV3Bundle @entity {
  id: ID!
  # price of ETH in usd
  ethPriceUSD: BigDecimal!
}

type UniV3Token @entity {
  # token address
  id: ID!
  # token symbol
  symbol: String!
  # token name
  name: String!
  # token decimals
  decimals: BigInt!
  # token total supply
  totalSupply: BigInt!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # transactions across all pools that include this token
  txCount: BigInt!
  # number of pools containing this token
  poolCount: BigInt!
  # liquidity across all pools in token units
  totalValueLocked: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # derived price in ETH
  derivedETH: BigDecimal!
}

type UniV3Pool @entity {
  # pool address
  id: ID!
  # creation
  createdAtTimestamp: BigInt!
  # block pool was created at
  createdAtBlockNumber: BigInt!
  # token0
  token0: UniV3Token!
  # token1
  token1: UniV3Token!
  # fee amount
  feeTier: BigInt!
  # in range liquidity
  liquidity: BigInt!
  # current price tracker
  sqrtPrice: BigInt!
  # tracker for global fee growth
  feeGrowthGlobal0X128: BigInt!
  # tracker for global fee growth
  feeGrowthGlobal1X128: BigInt!
  # token0 per token1
  token0Price: BigDecimal!
  # token1 per token0
  token1Price: BigDecimal!
  # current tick
  tick: BigInt
  # current observation index
  observationIndex: BigInt!
  # all time token0 swapped
  volumeToken0: BigDecimal!
  # all time token1 swapped
  volumeToken1: BigDecimal!
  # all time USD swapped
  volumeUSD: BigDecimal!
  # all time USD swapped, unfiltered for unreliable USD pools
  untrackedVolumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # all time number of transactions
  txCount: BigInt!
  # all time fees collected token0
  collectedFeesToken0: BigDecimal!
  # all time fees collected token1
  collectedFeesToken1: BigDecimal!
  # all time fees collected derived USD
  collectedFeesUSD: BigDecimal!
  # total token 0 across all ticks
  totalValueLockedToken0: BigDecimal!
  # total token 1 across all ticks
  totalValueLockedToken1: BigDecimal!
  # tvl derived ETH
  totalValueLockedETH: BigDecimal!
  # tvl USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # Fields used to help derived relationship
  liquidityProviderCount: BigInt! # used to detect new exchanges
}

type OrderComplete @entity {
  id: ID!
  timestamp: BigInt!
  index: Index!
  order: Order!

  sellToken: Asset!
  sellAmount: BigInt!
  sellTokenPrice: BigDecimal!

  buyToken: Asset!
  buyAmount: BigInt!
  buyTokenPrice: BigDecimal!

  transactionFee: BigInt!
  transactionGas: BigInt!
}

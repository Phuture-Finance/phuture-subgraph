type Asset @entity {
  "Address of the asset (hash)"
  id: ID!

  "Is this asset whitelisted"
  isWhitelisted: Boolean!

  "Total number of tokens in existence"
  totalSupply: BigInt!

  "Number of decimals this asset uses"
  decimals: BigInt!

  "Symbol of the asset"
  symbol: String!

  "Name of the asset"
  name: String!

  # "Number of indexes this asset belongs to"
  # indexCount: BigInt!

  "Indexes this asset belongs to"
  indexes: [IndexAsset!]! @derivedFrom(field: "asset")
  _indexes: [ID!]!

  "Base price of the asset on SushiSwap"
  basePriceSushi: BigDecimal!

  "Base price of the asset on Uniswap"
  basePriceUni: BigDecimal!

  "Base price of the asset"
  basePrice: BigDecimal!

  "Market capitalization of the asset"
  marketCap: BigInt!

  "The vTokens this asset has"
  vTokens: [vToken!]! @derivedFrom(field: "asset")
  _vTokens: [ID!]!

  "Amount of the asset in the vault"
  vaultReserve: BigDecimal!

  "Amount of the asset in the vault in base units"
  vaultBaseReserve: BigDecimal!

  # "Pairs where this asset is asset0"
  # pairsAsAsset0: [Pair!]! @derivedFrom(field: "asset0")
  #
  # "Pairs where this asset is asset1"
  # pairsAsAsset1: [Pair!]! @derivedFrom(field: "asset1")

  "Daily stats of the asset"
  dailyStats: [DailyAssetStat!]! @derivedFrom(field: "asset")

  "Uniswap V3 price oracle for this asset"
  oracle: UniV3PriceOracle
}

type ChainLink @entity {
  "Address of the ChainLink Aggregator Proxy"
  id: ID!

  "ChainLink Aggregator"
  aggregator: ChainLinkAggregator!
}

type ChainLinkAggregator @entity {
  "Address of the ChainLink Aggregator"
  id: ID!
  chainLink: ChainLink!
  asset: Asset!
  decimals: BigInt!
  description: String!
  answer: BigInt!
  updatedAt: BigInt!
  nextAgg: ChainLinkAggregator

  vaults: [SVVault!]!
}

type IndexFactory @entity {
  "Address (hash) of the factory"
  id: ID!

  "Type of the factory, e.g. 'managed'"
  type: String!

  "Address of the vTokenFactory of this factory"
  vTokenFactory: String!

  "Indexes created by this factory"
  indexes: [Index!]! @derivedFrom(field: "indexFactory")
}

type Index @entity {
  "Address (hash)"
  id: ID!
  type: String!

  # used for other stats like market cap
  totalSupply: BigInt!
  # metadata
  decimals: BigInt!
  symbol: String!
  name: String!

  users: [UserIndex!]! @derivedFrom(field: "index")
  assets: [IndexAsset!] @derivedFrom(field: "index")
  _assets: [ID!]!

  _inactiveAssets: [ID!]!
  inactiveAssets: [IndexAsset!] @derivedFrom(field: "inactiveIndex")

  transaction: Transaction!
  indexFactory: IndexFactory!

  marketCap: BigDecimal!
  uniqueHolders: BigInt!
  "price of the index in USD"
  basePrice: BigDecimal!
  "price of the index in ETH"
  basePriceETH: BigDecimal!
  "deprecated"
  baseVolume: BigDecimal!

  apy: BigDecimal!

  feeBurn: BigInt!
  feeMint: BigInt!

  "BP = 10000 ; ((((aumFeeInBP / BP) / (1 - aumFeeInBP / BP)) / 1e27) ** 365) - 1"
  feeAUMPercent: BigDecimal!

  "When index was created"
  created: BigInt!
  "Index Creation Category"
  sector: BigInt!

  hourlyStats: [HourlyIndexStat!]! @derivedFrom(field: "index")
  dailyStats: [DailyIndexStat!]! @derivedFrom(field: "index")
  weeklyStats: [WeeklyIndexStat!]! @derivedFrom(field: "index")
  monthlyStats: [MonthlyIndexStat!]! @derivedFrom(field: "index")
  yearlyStats: [YearlyIndexStat!]! @derivedFrom(field: "index")
}

type vToken @entity {
  "Address (hash)"
  id: ID!
  asset: Asset!
  tokenType: String!
  factory: String!
  platformTotalSupply: BigInt!
  platformTotalSupplyDec: BigDecimal!
  capitalization: BigDecimal!
  "depositedQuantity"
  deposited: BigInt!
  "reserveQuantity - quantity of the asset stored in vToken address"
  assetReserve: BigInt!
  "totalAmount - is the sum of assetReserve and deposited without taking interests into account"
  totalAmount: BigInt!

  vaultController: VaultController

  depositedPercentage: BigInt!
  apy: BigDecimal!
}

type VaultController @entity {
  id: ID!

  vToken: vToken!

  deposit: BigInt!
  depositedAt: BigInt!

  withdraw: BigInt!
  withdrawnAt: BigInt!

  stats: [VaultControllerStat!]! @derivedFrom(field: "vaultController")
}

type VaultControllerStat @entity {
  id: ID!

  vaultController: VaultController!

  deposit: BigInt!
  depositedAt: BigInt!

  withdraw: BigInt!
  withdrawnAt: BigInt!

  depositedPercentage: BigInt
  apy: BigDecimal!

  date: BigInt!
}

type IndexAsset @entity {
  id: ID! # Set to `${index.id}-${asset.id}`
  index: Index
  inactiveIndex: Index
  asset: Asset!
  weight: BigInt!
  shares: BigInt!
}

type User @entity {
  id: ID!

  indexes: [UserIndex!]! @derivedFrom(field: "user")
}

type UserIndex @entity {
  id: ID!

  user: User!
  index: Index!

  balance: BigDecimal!
  capitalization: BigDecimal!
  investedCapital: BigDecimal!
}

type UserCapitalization @entity {
  id: ID!

  index: Index!
  capitalization: BigDecimal!
  timestamp: BigInt!
  logIndex: BigInt!
}

type DailyCapitalization @entity {
  id: ID!
  "index referred to daily capitalisation metrics"
  index: Index!
  "capitalisation for the specific day"
  capitalization: BigDecimal!
  "price of the index in the day"
  basePrice: BigDecimal!
  "total supply of the index in specific"
  totalSupply: BigInt!
  "raw timestamp of the specific day"
  timestamp: BigInt!
  "log index value taken from event which triggered storing the metric"
  logIndex: BigInt!
}

type UserIndexHistory @entity {
  id: ID!

  "user account of the specific index holdings"
  user: User!
  index: Index!

  "shares of the index in user account"
  balance: BigDecimal!
  "USD equivalent of the user index holdings"
  capitalization: BigDecimal!
  "index total supply on the moment of the user balance calculation"
  totalSupply: BigInt!

  "holds orders of transfers in transaction"
  logIndex: BigInt!
  "timestamp matching the starting of day GMT"
  timestamp: BigInt!
}

type Transaction @entity {
  id: ID! # txn hash
  blockNumber: BigInt!
  timestamp: BigInt!

  value: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!

  transfers: [Transfer!]!
}

enum TransferType {
  Send
  Mint
  Burn
}

type Transfer @entity {
  id: ID! # Set to `${tx.id}-${transfer.id}`
  index: Index!

  transaction: Transaction!

  from: Bytes
  to: Bytes
  value: BigInt!

  type: TransferType!
}

type DailyAssetStat @entity {
  id: ID!
  date: Int!
  asset: Asset!

  vaultReserve: BigDecimal!
  vaultBaseReserve: BigDecimal!
  basePrice: BigDecimal!
}

type HourlyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  basePrice: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
  apy: BigDecimal!
}

type DailyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  marketCap: BigDecimal!
  uniqueHolders: BigInt!
  "Price of the index in USD"
  basePrice: BigDecimal!
  "Price of the index in chain native token"
  basePriceETH: BigDecimal!
  baseVolume: BigDecimal!
  apy: BigDecimal!
}

type WeeklyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  "price of the index in USD"
  basePrice: BigDecimal!
  "price of the index in ETH"
  basePriceETH: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
  apy: BigDecimal!
}

type MonthlyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  "price of the index in USD"
  basePrice: BigDecimal!
  "price of the index in ETH"
  basePriceETH: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
  apy: BigDecimal!
}

type YearlyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  "price of the index in USD"
  basePrice: BigDecimal!
  "price of the index in ETH"
  basePriceETH: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
  apy: BigDecimal!
}

# ----------------------------------------------------------------
#                             Saving Vault
# ----------------------------------------------------------------

type SVVault @entity {
  "Address (hash)"
  id: ID!
  totalSupply: BigInt!
  totalAssets: BigInt!
  decimals: BigInt!
  symbol: String!
  name: String!

  "price of the vault in USD"
  basePrice: BigDecimal!
  "price of the vault in ETH"
  basePriceETH: BigDecimal!

  feeBurn: BigInt!
  feeMint: BigInt!
  feeAUMPercent: BigDecimal!

  mint: [FCash!]!
  redeem: [FCash!]!

  uniqueHolders: BigInt!
  marketCap: BigDecimal!

  apy: BigDecimal!

  dailyStats: [SVDailyStat!]! @derivedFrom(field: "vault")

  created: BigInt!
}

type FCash @entity {
  id: ID!
  position: String!
  assetAmount: BigInt!
  amount: BigInt!
  maturity: BigInt!
  vault: SVVault!
  timestamp: BigInt!
  isRedeem: Boolean!
}

type SVUser @entity {
  id: ID!

  vaults: [UserVault!]! @derivedFrom(field: "user")
}

type UserVault @entity {
  id: ID!

  user: SVUser!
  vault: SVVault!

  balance: BigInt!
  capitalization: BigDecimal!
}

enum SVTransferType {
  Send
  Mint
  Burn
}

type SVTransfer @entity {
  id: ID!
  vault: SVVault!
  transaction: SVTransaction!
  type: SVTransferType!

  from: SVUser
  to: SVUser
  value: BigInt!

  timestamp: BigInt!
}

type SVTransaction @entity {
  id: ID! # txn hash
  blockNumber: BigInt!
  timestamp: BigInt!

  value: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
}

type SVDailyStat @entity {
  id: ID!

  date: BigInt!
  vault: SVVault!

  apy: BigDecimal!
  marketCap: BigDecimal!
  uniqueHolders: BigInt!
  "price of the vault in USD"
  basePrice: BigDecimal!
  "price of the vault in ETH"
  basePriceETH: BigDecimal!
}

type SVDailyCapitalization @entity {
  id: ID!
  "vault referred to daily capitalisation metrics"
  vault: SVVault!
  "capitalisation for the specific day"
  capitalization: BigDecimal!
  "price of the vault in the day"
  basePrice: BigDecimal!
  "total supply of saving vault"
  totalSupply: BigInt!
  "raw timestamp of the specific day"
  timestamp: BigInt!
  "log index value taken from event which triggered storing the metric"
  logIndex: BigInt!
}

type UserSVHistory @entity {
  id: ID!

  "user account of the specific vault holdings"
  user: SVUser!
  vault: SVVault!

  "shares of the vault in user account"
  balance: BigInt!
  "USD equivalent of the user vault holdings"
  capitalization: BigDecimal!
  "vault total supply on the moment of the user balance calculation"
  totalSupply: BigInt!

  "holds orders of transfers in transaction"
  logIndex: BigInt!
  "timestamp matching the starting of day GMT"
  timestamp: BigInt!
}

type DailyUserSVHistory @entity {
  id: ID!

  user: SVUser!
  vault: SVVault!

  total: BigDecimal!
  totalCap: BigDecimal!

  "vault total supply on the moment of the user balance calculation"
  totalSupply: BigInt!
  "timestamp matching the starting of day GMT"
  timestamp: BigInt!
  "holds orders of transfers in transaction"
  logIndex: BigInt!
}

# ----------------------------------------------------------------
#                               UniswapV3
# ----------------------------------------------------------------

# stores UniswapV3PriceOracle addresses
type UniV3PriceOracle @entity {
  id: ID!

  priceOracle: String!

  asset0: Asset!
  asset1: Asset!
}

type UniV3PathPriceOracle @entity {
  id: ID!

  pathPriceOracle: String!

  asset0: Asset!
  asset1: Asset!
}

# stores for USD calculations
type UniV3Bundle @entity {
  id: ID!
  # price of ETH in usd
  ethPriceUSD: BigDecimal!
}

type UniV3Token @entity {
  # token address
  id: ID!
  # token symbol
  symbol: String!
  # token name
  name: String!
  # token decimals
  decimals: BigInt!
  # token total supply
  totalSupply: BigInt!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # transactions across all pools that include this token
  txCount: BigInt!
  # number of pools containing this token
  poolCount: BigInt!
  # liquidity across all pools in token units
  totalValueLocked: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # derived price in ETH
  derivedETH: BigDecimal!
}

type UniV3Pool @entity {
  # pool address
  id: ID!
  # creation
  createdAtTimestamp: BigInt!
  # block pool was created at
  createdAtBlockNumber: BigInt!
  # token0
  token0: UniV3Token!
  # token1
  token1: UniV3Token!
  # fee amount
  feeTier: BigInt!
  # in range liquidity
  liquidity: BigInt!
  # current price tracker
  sqrtPrice: BigInt!
  # tracker for global fee growth
  feeGrowthGlobal0X128: BigInt!
  # tracker for global fee growth
  feeGrowthGlobal1X128: BigInt!
  # token0 per token1
  token0Price: BigDecimal!
  # token1 per token0
  token1Price: BigDecimal!
  # current tick
  tick: BigInt
  # current observation index
  observationIndex: BigInt!
  # all time token0 swapped
  volumeToken0: BigDecimal!
  # all time token1 swapped
  volumeToken1: BigDecimal!
  # all time USD swapped
  volumeUSD: BigDecimal!
  # all time USD swapped, unfiltered for unreliable USD pools
  untrackedVolumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # all time number of transactions
  txCount: BigInt!
  # all time fees collected token0
  collectedFeesToken0: BigDecimal!
  # all time fees collected token1
  collectedFeesToken1: BigDecimal!
  # all time fees collected derived USD
  collectedFeesUSD: BigDecimal!
  # total token 0 across all ticks
  totalValueLockedToken0: BigDecimal!
  # total token 1 across all ticks
  totalValueLockedToken1: BigDecimal!
  # tvl derived ETH
  totalValueLockedETH: BigDecimal!
  # tvl USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # Fields used to help derived relationship
  liquidityProviderCount: BigInt! # used to detect new exchanges
}

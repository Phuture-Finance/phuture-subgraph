type Asset @entity {
  "Address (hash)"
  id: ID!

  isWhitelisted: Boolean!

  # used for other stats like marketcap
  totalSupply: BigInt!
  # mirrored from the smart contract
  decimals: BigInt!
  symbol: String!
  name: String!

  indexCount: BigInt!
  _indexes: [ID!]!
  indexes: [IndexAsset!]! @derivedFrom(field: "asset")

  basePriceSushi: BigDecimal!
  basePrice: BigDecimal!
  marketCap: BigInt!

  _vTokens: [ID!]!
  vTokens: [vToken!]! @derivedFrom(field: "asset")

  vaultReserve: BigDecimal!
  vaultBaseReserve: BigDecimal!

  pairsAsAsset0: [Pair!]! @derivedFrom(field: "asset0")
  pairsAsAsset1: [Pair!]! @derivedFrom(field: "asset1")

  dailyStats: [DailyAssetStat!]! @derivedFrom(field: "asset")
}

type Swap @entity {
  id: ID!

  pairs: [Pair!]! @derivedFrom(field: "swap")
}

type Pair @entity {
  id: ID!

  swap: Swap!

  asset0: Asset!
  asset1: Asset!

  totalSupply: BigInt!

  asset0Reserve: BigDecimal!
  asset1Reserve: BigDecimal!
}

type SushiPair @entity {
  id: ID!

  swap: Swap!

  asset0: Asset!
  asset1: Asset!

  totalSupply: BigInt!

  asset0Reserve: BigDecimal!
  asset1Reserve: BigDecimal!
}

type DEX @entity {
  id: ID!
  router: String!
  type: String!
}

type IndexFactory @entity {
  "Address (hash) of the factory"
  id: ID!
  type: String!

  vTokenFactory: String!

  indices: [Index!]! @derivedFrom(field: "indexFactory")
}

type Index @entity {
  "Address (hash)"
  id: ID!
  type: String!

  # used for other stats like marketcap
  totalSupply: BigInt!
  # metadata
  decimals: BigInt!
  symbol: String!
  name: String!

  users: [UserIndex!]! @derivedFrom(field: "index")
  assets: [IndexAsset!]! @derivedFrom(field: "index")
  _assets: [ID!]!

  transaction: Transaction!
  indexFactory: IndexFactory!

  marketCap: BigDecimal!
  uniqueHolders: BigInt!
  basePrice: BigDecimal!
  baseVolume: BigDecimal!

  feeBurn: BigInt!
  feeMint: BigInt!
  feeAUM: BigInt!

  "BP = 10000 ; ((((aumFeeInBP / BP) / (1 - aumFeeInBP / BP)) / 1e27) ** 365) - 1"
  feeAUMPercent: BigInt!

  "When index was created"
  created: BigInt!
  "Index Creation Category"
  sector: BigInt!

  hourlyStats: [HourlyIndexStat!]! @derivedFrom(field: "index")
  dailyStats: [DailyIndexStat!]! @derivedFrom(field: "index")
  weeklyStats: [WeeklyIndexStat!]! @derivedFrom(field: "index")
  monthlyStats: [MonthlyIndexStat!]! @derivedFrom(field: "index")
  yearlyStats: [YearlyIndexStat!]! @derivedFrom(field: "index")
}

enum OrderSideType {
  Buy
  Sell
}

type Order @entity {
  "Address (hash)"
  id: ID!
  index: Index!
  order_id: BigInt!
  orderDetails: [OrderDetailsInfo!]! @derivedFrom(field: "order")
}

type OrderDetailsInfo @entity {
  id: ID! # Set to `${order.id}-${asset.id}`
  order: Order!
  asset: Asset!
  shares: BigInt!
  side: OrderSideType!
}

type _OrderIdLink @entity {
  id: ID!
  index: Index!
}

type vToken @entity {
  "Address (hash)"
  id: ID!
  asset: Asset!
  tokenType: String!
  factory: String!
  deposited: BigInt!
  platformTotalSupply: BigInt!
  platformTotalSupplyDec: BigDecimal!
  capitalization: BigDecimal!
  assetReserve: BigDecimal!
}

type IndexAsset @entity {
  id: ID! # Set to `${index.id}-${asset.id}`
  index: Index!
  asset: Asset!
  weight: BigInt!
  shares: BigInt!
}

type User @entity {
  id: ID!

  indexes: [UserIndex!]! @derivedFrom(field: "user")
}

type UserIndex @entity {
  id: ID!

  user: User!
  index: Index!

  balance: BigDecimal!
}

type UserIndexHistory @entity {
  id: ID!

  timestamp: BigInt!

  user: User!
  index: Index!

  balance: BigDecimal!
}

type DailyUserIndexHistory @entity {
  id: ID!

  # timestamp matching the starting of day GMT
  timestamp: BigInt!

  user: User!
  index: Index!

  total: BigDecimal!
  number: BigDecimal!

  avgBalance: BigDecimal!
}

type Transaction @entity {
  id: ID! # txn hash
  blockNumber: BigInt!
  timestamp: BigInt!

  value: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!

  transfers: [Transfer!]!
}

enum TransferType {
  Send
  Mint
  Burn
}

type Transfer @entity {
  id: ID! # Set to `${tx.id}-${transfer.id}`
  index: Index!

  transaction: Transaction!

  from: Bytes
  to: Bytes
  value: BigInt!

  type: TransferType!
}

type Stat @entity {
  # index factory address
  id: ID!

  indexCount: BigInt!
  totalValueLocked: BigDecimal!
}

type DailyStat @entity {
  id: ID!
  date: Int!

  indexCount: BigInt!
  totalValueLocked: BigDecimal!
}

type DailyAssetStat @entity {
  id: ID!
  date: Int!
  asset: Asset!

  vaultReserve: BigDecimal!
  vaultBaseReserve: BigDecimal!
  basePrice: BigDecimal!
}

type HourlyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  basePrice: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
}

type DailyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  marketCap: BigDecimal!
  uniqueHolders: BigInt!
  basePrice: BigDecimal!
  baseVolume: BigDecimal!
}

type WeeklyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  basePrice: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
}

type MonthlyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  basePrice: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
}

type ThreeMonthIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  basePrice: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
}

type HalfYearIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  basePrice: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
}

type YearlyIndexStat @entity {
  id: ID!
  date: Int!
  index: Index!

  basePrice: BigDecimal!
  marketCap: BigDecimal!
  baseVolume: BigDecimal!
  uniqueHolders: BigInt!
}
